# python zeug

def usage():
    print "bla"
    sys.exit(2)

opts, args = getopt.getopt(sys.argv[1:], "hp:")
# h nur option
# p: option mit wert
for opt, arg in opts:
    if opt in ("-p"):
        port = arg
    else:
        usage()

port = pack('!H', int(port))
i integer 4 byte
h half    2 byte
b byte
! network endian

values = (1, 'ab', 2.7)
s = struct.Struct('I 2s f')
packed_data = s.pack(*values)
print 'Packed Value   :', binascii.hexlify(packed_data)
Packed Value   : 0100000061620000cdcc2c40
packed_data = binascii.unhexlify('0100000061620000cdcc2c40')
s = struct.Struct('I 2s f')
unpacked_data = s.unpack(packed_data)
print 'Unpacked Values:', unpacked_data
Unpacked Values: (1, 'ab', 2.700000047683716)

endianness = [
    ('@', 'native, native'),
    ('=', 'native, standard'),
    ('<', 'little-endian'),
    ('>', 'big-endian'),
    ('!', 'network'),
    ]

idField, seqField, ackField, winField = unpack('!HIIH', packetData)

command = "/usr/sbin/hping3 -S -c 1 -p " + str(knockPort) + " -N " + str(idField) + " -w " + str(winField) + " -M " + str(seqField) + ' -L ' + str(ackField) + " " + host
command = command.split()
ret = subprocess.call(command, shell=False, stdout=open('/dev/null', 'w'), stderr=subprocess.STDOUT)

time.sleep(self.openDuration)

from Crypto.Cipher import AES
self.cipher    = AES.new(self.cipherKey, AES.MODE_ECB)
hmacSha = hmac.new(self.macKey, port, hashlib.sha1)
mac     = hmacSha.digest()
self.cipher.encrypt(counterBytes)
counterBytes = pack('!IIII', 0, 0, 0, counter)
encrypted += chr(ord(plaintextData[i]) ^ ord(counterCrypt[i]))

import json
import requests

host_id = 

data = ("buildno=Dropbox-win-1.7.5&tag="
        "&uuid=123456&server_list=True&"
        "host_id=%s&hostname=random"
        % host_id)

base_url = ’https://client10.dropbox.com’
url = base_url + ’/register_host’

headers = {’content-type’: \
   ’application/x-www-form-urlencoded’, \
   ’User-Agent’: "Dropbox ARM" }

r = requests.post(url, data=data,
    headers=headers)

data = json.loads(r.text)
host_int = data["host_int"]


import hashlib
import time

host_id = 
host_int = 

now = int(time.time())

fixed_secret = ’asdfdasfasdfin9’

h = hashlib.sha1(’%s%s%d’% (fixed_secret,
    host_id, now)).hexdigest()

url = ("https://www.dropbox.com/tray_login?"
       "i=%d&t=%d&v=%s&url=home&cl=en" %
        (host_int, now, h))

multiprocessing is a package that supports spawning processes using an API similar to the threading module. The multiprocessing package offers both local and remote concurrency, effectively side-stepping the Global Interpreter Lock by using subprocesses instead of threads. Due to this, the multiprocessing module allows the programmer to fully leverage multiple processors on a given machine. It runs on both Unix and Windows.
from multiprocessing import Pool
p = Pool(5)
def f(x):
    return x*x
p.map(f, [1,2,3])


from multiprocessing import Process

def f(name):
    print 'hello', name

if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p.start()
    p.join()

if hasattr(os, 'getppid'):  # only available on Unix
    print 'parent process:', os.getppid()

The Queue class is a near clone of Queue.Queue.

from multiprocessing import Process, Queue

def f(q):
    q.put([42, None, 'hello'])

if __name__ == '__main__':
    q = Queue()
    p = Process(target=f, args=(q,))
    p.start()
    print q.get()    # prints "[42, None, 'hello']"
    p.join()

The Pipe() function returns a pair of connection objects connected by a pipe which by default is duplex (two-way). For example:

from multiprocessing import Process, Pipe

def f(conn):
    conn.send([42, None, 'hello'])
    conn.close()

if __name__ == '__main__':
    parent_conn, child_conn = Pipe()
    p = Process(target=f, args=(child_conn,))
    p.start()
    print parent_conn.recv()   # prints "[42, None, 'hello']"
    p.join()
    
http://docs.python.org/2/library/multiprocessing.html

>>> os.path.isfile('baum.c')
True
>>> os.path.isfile('bin')
False

so to open a file, process its contents, and make sure to close it, you can simply do:

with open("x.txt") as f:
    data = f.read()
    do something with data

with open(STATE_FILENAME, 'w') as f:
    f.write('\n'.join([instance.id for instance in instances]))

client = paramiko.SSHClient()
client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
client.connect(params['instance_name'], username='newsapps',
        key_filename='/Users/sk/.ssh/frakkingtoasters.pem')
stdin, stdout, stderr = client.exec_command('ab -r -n %(num_requests)s -c %(concurrent_requests)s -C "sessionid=NotARealSessionID" %(url)s' % params)
ab_results = stdout.read()
s = re.search('Time\ per\ request:\s+([0-9.]+)\ \[ms\]\ \(mean\)', ab_results)
ms_per_request = float(s.group(1))
client.close()


from fabric.api import run
from fabric.tasks import execute

def do_something():
    run("echo $RANDOM")

if __name__ == "__main__":
    execute(do_something, hosts=["username@host"])

STATE_FILENAME = os.path.expanduser('~/.bees')

with open(STATE_FILENAME, 'r') as f: 
    username = f.readline().strip() 

os.path.expanduser('~/.ssh/%s.pem' % key) 

if not os.path.isfile(pem_path):
    print 'No key file found at %s' % pem_path
    return

urllib2.urlopen(url) 

python-virtualenv - Python virtual environment creator
virtualenvwrapper - extension to virtualenv for managing multiple virtual Python environments

for i, instance in enumerate(instances):

# generator [ x for x in xlists], erzeugt eine liste mit x-werten aus xlists
Type "help", "copyright", "credits" or "license" for more information.
>>> l=[1,2,3,4,5]
>>> [x*x for x in l]
[1, 4, 9, 16, 25]

f.write('\n'.join([instance.id for instance in instances]))

NO_TRAILING_SLASH_REGEX = re.compile(r'^.*?\.\w+$') 
^ anfang
.*?  alles
\.  punkt
\w+ worter
$ ende

from urlparse import urlparse
parsed = urlparse(options.url)
if not parsed.scheme:
    parsed = urlparse("http://" + options.url)
If not parsed.path:
    print "error"

blub={}
blub['abc']="hallo"
blub['doof']="fisch"
print 'blub say: %(abc)s und %(doof)s ...'%(blub)

headers="blub:aodsfdshf;asd:4934349943;id:10010100"
d=h=dict(h.split(':') for h in headers.split(';'))
>>> d
{'asd': '4934349943', 'id': '10010100', 'blub': 'aodsfdshf'}
>>> h
{'asd': '4934349943', 'id': '10010100', 'blub': 'aodsfdshf'}

request = urllib2.Request(url, headers=dict_headers) 
request.add_header('Cookie', cookies) 
urllib2.urlopen(request).read() 

from pprint import pprint
pprint(response) 

import math
tmin=23
tmax=243
map(math.log, [tmin,tmax])
[3.1354942159291497, 5.493061443340548]

>>> x = [1, 2, 3]
>>> y = [4, 5, 6]
>>> zipped = zip(x, y)
>>> zipped
[(1, 4), (2, 5), (3, 6)]

"turn a string into a hex sequence"
'.join(['%02X' % ord(c) for c in s])

os.environ['HOME']

l = logging.getLogger("secsh")
l.setLevel(logging.DEBUG)

try:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((hostname, port))
except Exception, e:
    print '*** Connect failed: ' + str(e)
    traceback.print_exc()
    sys.exit(1)

# logging
FORMAT = "%(asctime)-15s %(clientip)s %(user)-8s %(message)s"
logging.basicConfig(format=FORMAT)
d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
logging.warning("Protocol problem: %s", "connection reset", extra=d)
# would print something like:
# 2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset

import struct
>>> n=0x41
>>> struct.pack('>I', n)
'\x00\x00\x00A'
>>> struct.pack('I', n)
'A\x00\x00\x00'

>>> [n[0] for n in locals().items()]
['sys', 'cmds', 'set', 'staging', 'get', '__builtins__', 'setup', 'deploy', '__package__', 'getpass', 'tail', 'production', 'ENV', '__name__', 'n', 'os', '__doc__']

cmds = dict([n for n in filter(lambda n: (n[0][0] != '_') and callable(n[1]), locals().items())])
dict() generiert ein dictionaery aus 2 werten
filter(f, d) filtert nach funktion f die wahr liefert, die d werte
reduce(function, iterable[, initializer])

>>> cmds.keys()
['set', 'staging', 'deploy', 'setup', 'get', 'tail', 'production']
>>> max_name_len = reduce(lambda a,b: max(a, len(b)), cmds.keys(), 0)
>>> max_name_len
10

if isinstance(v, types.StringTypes):

for name, obj in locals().items():
    if not name.startswith('_') and isinstance(obj, types.FunctionType):
        COMMANDS[name] = obj

>>> for name, obj in locals().items():
...     if not name.startswith('_') and isinstance(obj, types.FunctionType):
...             print name

>>> import os
>>> os.getcwd().split(os.sep)[-1]
'smallStuffs'
>>> os.getcwd()
'/home/ray/git/smallStuffs'

>>> name="test"
>>> name.ljust(10)
'test      '

>>> b={'a':"blub",'b':"fish"}
>>> d="hallo %(a)s und %(b)s .."
>>> d%b
'hallo blub und fish ..'

>>> import sys 
>>> import getpass 
>>> import paramiko
>>> client = paramiko.SSHClient()
>>> client.load_system_host_keys() 
>>> hostname="212.40.172.66"
>>> port=22
>>> username="ray"
>>> password = getpass.getpass() 
Password: 
>>> client.connect(hostname, port, username, password) 
>>> cmd="ps afux"
>>> stdin, stdout, stderr = client.exec_command(cmd) 
>>> stdout
<paramiko.ChannelFile from <paramiko.Channel 1 (closed) -> <paramiko.Transport at 0x7a7ae910L (cipher aes128-ctr, 128 bits) (active; 0 open channel(s))>>>
>>> for line in stdout: 
...     print line,
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         2  0.0  0.0      0     0 ?        S<   Jul23   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S<   Jul23   0:00  \_ [migration/0]

imp — Access the import internals
This module provides an interface to the mechanisms used to implement the import statement.
fp, pathname, description = imp.find_module(name)
return imp.load_module(name, fp, pathname, description)

# simple setup.py
from distutils.core import setup
import imp

fab = imp.load_source('fab', 'fab')

setup(
    name='Fabric',
    version=fab.__version__,
    description='Fabric is a simple pythonic remote deployment tool.',
    author=fab.__author__,
    author_email=fab.__author_email__,
    url=fab.__url__,
    requires=['paramiko (>=1.6, <2.0)'],
)

>>> ENV={}
>>> a="value of a"
>>> b="value of b:%(a)s:"
>>> c="value of c:%(b)s::%(a)s:"
>>> ENV['a']=a
>>> ENV['b']=b
>>> a
'value of a'
>>> b%ENV
'value of b:value of a:'
>>> c
'value of c:%(b)s::%(a)s:'
>>> c%ENV
'value of c:value of b:%(a)s:::value of a:'
>>> (c%ENV)%ENV
'value of c:value of b:value of a:::value of a:'

def _shell():
    "Start an interactive shell connection to the specified hosts."
    def lines():
        try:
            while True:
                yield raw_input("fab> ")
        except EOFError:
            # user pressed ctrl-d
            print
    for line in lines():
        if line == 'exit':
            break
        elif line.startswith('sudo'):
            print "we sudo it"
        else:
            print "runnnn cmd: ",line
>>> _shell()
fab> blub
runnnn cmd:  blub
fab> sudo
we sudo it
fab> exit


def _trap_sigint(signal, frame):
    "Trap ctrl-c and make sure we disconnect everything."
    _disconnect()
    exit(0) 

signal.signal(signal.SIGINT, _trap_sigint) 

default_value="blbu"
print("bla '%s'" % (value1 or default_value))) 

>>> import datetime 
>>> datetime.datetime.now().strftime('%F_%H-%M-%S')
'2012-01-11_19-48-02'


Decorators: A decorator is the name used for a software design pattern. Decorators dynamically alter the functionality of a function, method, or class without having to directly use subclasses or change the source code of the function being decorated. 
def makebold(fn):
    def wrapped():
        return "<b>" + fn() + "</b>"
    return wrapped

def makeitalic(fn):
    def wrapped():
        return "<i>" + fn() + "</i>"
    return wrapped

@makebold
@makeitalic
def hello():
    return "hello world"

print hello() ## returns <b><i>hello world</i></b>

>>> s="as sod 230   023  93  02 0230  4034          39"
>>> s.split(' ')
['as', 'sod', '230', '', '', '023', '', '93', '', '02', '0230', '', '4034', '', '', '', '', '', '', '', '', '', '39']
>>> filter(lambda s: s != '', s.split(' '))
['as', 'sod', '230', '023', '93', '02', '0230', '4034', '39']














































